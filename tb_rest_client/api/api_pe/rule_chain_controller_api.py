# coding: utf-8

"""
    ThingsBoard REST API

     ThingsBoard Professional Edition IoT platform REST API documentation.  # noqa: E501

    OpenAPI spec version: 3.9.0PE
    Contact: info@thingsboard.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

#  Copyright 2025. ThingsBoard
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tb_rest_client.api_client import ApiClient


class RuleChainControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def assign_rule_chain_to_edge_using_post(self, edge_id, rule_chain_id, **kwargs):  # noqa: E501
        """Assign rule chain to edge (assignRuleChainToEdge)  # noqa: E501

        Creates assignment of an existing rule chain to an instance of The Edge. Assignment works in async way - first, notification event pushed to edge service queue on platform. Second, remote edge service will receive a copy of assignment rule chain (Edge will receive this instantly, if it's currently connected, or once it's going to be connected to platform). Third, once rule chain will be delivered to edge service, it's going to start processing messages locally.   Only rule chain with type 'EDGE' can be assigned to edge.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_rule_chain_to_edge_using_post(edge_id, rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: edgeId (required)
        :param str rule_chain_id: ruleChainId (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_rule_chain_to_edge_using_post_with_http_info(edge_id, rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_rule_chain_to_edge_using_post_with_http_info(edge_id, rule_chain_id, **kwargs)  # noqa: E501
            return data

    def assign_rule_chain_to_edge_using_post_with_http_info(self, edge_id, rule_chain_id, **kwargs):  # noqa: E501
        """Assign rule chain to edge (assignRuleChainToEdge)  # noqa: E501

        Creates assignment of an existing rule chain to an instance of The Edge. Assignment works in async way - first, notification event pushed to edge service queue on platform. Second, remote edge service will receive a copy of assignment rule chain (Edge will receive this instantly, if it's currently connected, or once it's going to be connected to platform). Third, once rule chain will be delivered to edge service, it's going to start processing messages locally.   Only rule chain with type 'EDGE' can be assigned to edge.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_rule_chain_to_edge_using_post_with_http_info(edge_id, rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: edgeId (required)
        :param str rule_chain_id: ruleChainId (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_id', 'rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_rule_chain_to_edge_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_id' is set
        if ('edge_id' not in params or
                params['edge_id'] is None):
            raise ValueError("Missing the required parameter `edge_id` when calling `assign_rule_chain_to_edge_using_post`")  # noqa: E501
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `assign_rule_chain_to_edge_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_id' in params:
            path_params['edgeId'] = params['edge_id']  # noqa: E501
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/edge/{edgeId}/ruleChain/{ruleChainId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_rule_chain_using_delete(self, rule_chain_id, **kwargs):  # noqa: E501
        """Delete rule chain (deleteRuleChain)  # noqa: E501

        Deletes the rule chain. Referencing non-existing rule chain Id will cause an error. Referencing rule chain that is used in the device profiles will cause an error.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_rule_chain_using_delete(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_rule_chain_using_delete_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_rule_chain_using_delete_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def delete_rule_chain_using_delete_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Delete rule chain (deleteRuleChain)  # noqa: E501

        Deletes the rule chain. Referencing non-existing rule chain Id will cause an error. Referencing rule chain that is used in the device profiles will cause an error.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_rule_chain_using_delete_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_rule_chain_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `delete_rule_chain_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_rule_chains_using_get(self, limit, **kwargs):  # noqa: E501
        """Export Rule Chains  # noqa: E501

        Exports all tenant rule chains as one JSON.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_rule_chains_using_get(limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: A limit of rule chains to export. (required)
        :return: RuleChainData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_rule_chains_using_get_with_http_info(limit, **kwargs)  # noqa: E501
        else:
            (data) = self.export_rule_chains_using_get_with_http_info(limit, **kwargs)  # noqa: E501
            return data

    def export_rule_chains_using_get_with_http_info(self, limit, **kwargs):  # noqa: E501
        """Export Rule Chains  # noqa: E501

        Exports all tenant rule chains as one JSON.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_rule_chains_using_get_with_http_info(limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: A limit of rule chains to export. (required)
        :return: RuleChainData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_rule_chains_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'limit' is set
        if ('limit' not in params or
                params['limit'] is None):
            raise ValueError("Missing the required parameter `limit` when calling `export_rule_chains_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChains/export{?limit}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChainData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_auto_assign_to_edge_rule_chains_using_get(self, **kwargs):  # noqa: E501
        """Get Auto Assign To Edge Rule Chains (getAutoAssignToEdgeRuleChains)  # noqa: E501

        Returns a list of Rule Chains that will be assigned to a newly created edge. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auto_assign_to_edge_rule_chains_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[RuleChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_auto_assign_to_edge_rule_chains_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_auto_assign_to_edge_rule_chains_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_auto_assign_to_edge_rule_chains_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Auto Assign To Edge Rule Chains (getAutoAssignToEdgeRuleChains)  # noqa: E501

        Returns a list of Rule Chains that will be assigned to a newly created edge. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auto_assign_to_edge_rule_chains_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[RuleChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_auto_assign_to_edge_rule_chains_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/autoAssignToEdgeRuleChains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RuleChain]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_edge_rule_chains_using_get(self, edge_id, page_size, page, **kwargs):  # noqa: E501
        """Get Edge Rule Chains (getEdgeRuleChains)  # noqa: E501

        Returns a page of Rule Chains assigned to the specified edge. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_edge_rule_chains_using_get(edge_id, page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: A string value representing the edge id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the rule chain name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataRuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_edge_rule_chains_using_get_with_http_info(edge_id, page_size, page, **kwargs)  # noqa: E501
        else:
            (data) = self.get_edge_rule_chains_using_get_with_http_info(edge_id, page_size, page, **kwargs)  # noqa: E501
            return data

    def get_edge_rule_chains_using_get_with_http_info(self, edge_id, page_size, page, **kwargs):  # noqa: E501
        """Get Edge Rule Chains (getEdgeRuleChains)  # noqa: E501

        Returns a page of Rule Chains assigned to the specified edge. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_edge_rule_chains_using_get_with_http_info(edge_id, page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: A string value representing the edge id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the rule chain name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataRuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_id', 'page_size', 'page', 'text_search', 'sort_property', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_edge_rule_chains_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_id' is set
        if ('edge_id' not in params or
                params['edge_id'] is None):
            raise ValueError("Missing the required parameter `edge_id` when calling `get_edge_rule_chains_using_get`")  # noqa: E501
        # verify the required parameter 'page_size' is set
        if ('page_size' not in params or
                params['page_size'] is None):
            raise ValueError("Missing the required parameter `page_size` when calling `get_edge_rule_chains_using_get`")  # noqa: E501
        # verify the required parameter 'page' is set
        if ('page' not in params or
                params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `get_edge_rule_chains_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_id' in params:
            path_params['edgeId'] = params['edge_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'text_search' in params:
            query_params.append(('textSearch', params['text_search']))  # noqa: E501
        if 'sort_property' in params:
            query_params.append(('sortProperty', params['sort_property']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/edge/{edgeId}/ruleChains{?page,pageSize,sortOrder,sortProperty,textSearch}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageDataRuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_latest_rule_node_debug_input_using_get(self, rule_node_id, **kwargs):  # noqa: E501
        """Get latest input message (getLatestRuleNodeDebugInput)  # noqa: E501

        Gets the input message from the debug events for specified Rule Chain Id. Referencing non-existing rule chain Id will cause an error.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_rule_node_debug_input_using_get(rule_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_node_id: A string value representing the rule node id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: JsonNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_latest_rule_node_debug_input_using_get_with_http_info(rule_node_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_latest_rule_node_debug_input_using_get_with_http_info(rule_node_id, **kwargs)  # noqa: E501
            return data

    def get_latest_rule_node_debug_input_using_get_with_http_info(self, rule_node_id, **kwargs):  # noqa: E501
        """Get latest input message (getLatestRuleNodeDebugInput)  # noqa: E501

        Gets the input message from the debug events for specified Rule Chain Id. Referencing non-existing rule chain Id will cause an error.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_latest_rule_node_debug_input_using_get_with_http_info(rule_node_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_node_id: A string value representing the rule node id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: JsonNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_node_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_latest_rule_node_debug_input_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_node_id' is set
        if ('rule_node_id' not in params or
                params['rule_node_id'] is None):
            raise ValueError("Missing the required parameter `rule_node_id` when calling `get_latest_rule_node_debug_input_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_node_id' in params:
            path_params['ruleNodeId'] = params['rule_node_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleNode/{ruleNodeId}/debugIn', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_chain_by_id_using_get(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain (getRuleChainById)  # noqa: E501

        Fetch the Rule Chain object based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_by_id_using_get(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_chain_by_id_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_chain_by_id_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def get_rule_chain_by_id_using_get_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain (getRuleChainById)  # noqa: E501

        Fetch the Rule Chain object based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_by_id_using_get_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_chain_by_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `get_rule_chain_by_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_chain_meta_data_using_get(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain (getRuleChainById)  # noqa: E501

        Fetch the Rule Chain Metadata object based on the provided Rule Chain Id. The metadata object contains information about the rule nodes and their connections.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_meta_data_using_get(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChainMetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_chain_meta_data_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_chain_meta_data_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def get_rule_chain_meta_data_using_get_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain (getRuleChainById)  # noqa: E501

        Fetch the Rule Chain Metadata object based on the provided Rule Chain Id. The metadata object contains information about the rule nodes and their connections.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_meta_data_using_get_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChainMetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_chain_meta_data_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `get_rule_chain_meta_data_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChainMetaData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_chain_output_labels_usage_using_get(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get output labels usage (getRuleChainOutputLabelsUsage)  # noqa: E501

        Fetch the list of rule chains and the relation types (labels) they use to process output of the current rule chain based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_output_labels_usage_using_get(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: list[RuleChainOutputLabelsUsage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_chain_output_labels_usage_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_chain_output_labels_usage_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def get_rule_chain_output_labels_usage_using_get_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get output labels usage (getRuleChainOutputLabelsUsage)  # noqa: E501

        Fetch the list of rule chains and the relation types (labels) they use to process output of the current rule chain based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_output_labels_usage_using_get_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: list[RuleChainOutputLabelsUsage]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_chain_output_labels_usage_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `get_rule_chain_output_labels_usage_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/output/labels/usage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RuleChainOutputLabelsUsage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_chain_output_labels_using_get(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain output labels (getRuleChainOutputLabels)  # noqa: E501

        Fetch the unique labels for the \"output\" Rule Nodes that belong to the Rule Chain based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_output_labels_using_get(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_chain_output_labels_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_chain_output_labels_using_get_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def get_rule_chain_output_labels_using_get_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Get Rule Chain output labels (getRuleChainOutputLabels)  # noqa: E501

        Fetch the unique labels for the \"output\" Rule Nodes that belong to the Rule Chain based on the provided Rule Chain Id. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chain_output_labels_using_get_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_chain_output_labels_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `get_rule_chain_output_labels_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/output/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rule_chains_using_get(self, page_size, page, **kwargs):  # noqa: E501
        """Get Rule Chains (getRuleChains)  # noqa: E501

        Returns a page of Rule Chains owned by tenant. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chains_using_get(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str type: Rule chain type (CORE or EDGE)
        :param str text_search: The case insensitive 'substring' filter based on the rule chain name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataRuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rule_chains_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rule_chains_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
            return data

    def get_rule_chains_using_get_with_http_info(self, page_size, page, **kwargs):  # noqa: E501
        """Get Rule Chains (getRuleChains)  # noqa: E501

        Returns a page of Rule Chains owned by tenant. The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rule_chains_using_get_with_http_info(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str type: Rule chain type (CORE or EDGE)
        :param str text_search: The case insensitive 'substring' filter based on the rule chain name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataRuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'page', 'type', 'text_search', 'sort_property', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rule_chains_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_size' is set
        if ('page_size' not in params or
                params['page_size'] is None):
            raise ValueError("Missing the required parameter `page_size` when calling `get_rule_chains_using_get`")  # noqa: E501
        # verify the required parameter 'page' is set
        if ('page' not in params or
                params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `get_rule_chains_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'text_search' in params:
            query_params.append(('textSearch', params['text_search']))  # noqa: E501
        if 'sort_property' in params:
            query_params.append(('sortProperty', params['sort_property']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChains{?page,pageSize,sortOrder,sortProperty,textSearch,type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageDataRuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_rule_chains_using_post(self, **kwargs):  # noqa: E501
        """Import Rule Chains  # noqa: E501

        Imports all tenant rule chains as one JSON.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_rule_chains_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChainData body:
        :param bool overwrite: Enables overwrite for existing rule chains with the same name.
        :return: list[RuleChainImportResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_rule_chains_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.import_rule_chains_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def import_rule_chains_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Import Rule Chains  # noqa: E501

        Imports all tenant rule chains as one JSON.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_rule_chains_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChainData body:
        :param bool overwrite: Enables overwrite for existing rule chains with the same name.
        :return: list[RuleChainImportResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'overwrite']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_rule_chains_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'overwrite' in params:
            query_params.append(('overwrite', params['overwrite']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChains/import{?overwrite}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RuleChainImportResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_tbel_enabled_using_get(self, **kwargs):  # noqa: E501
        """Is TBEL script executor enabled  # noqa: E501

        Returns 'True' if the TBEL script execution is enabled  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_tbel_enabled_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_tbel_enabled_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.is_tbel_enabled_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def is_tbel_enabled_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Is TBEL script executor enabled  # noqa: E501

        Returns 'True' if the TBEL script execution is enabled  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_tbel_enabled_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_tbel_enabled_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/tbelEnabled', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_rule_chain_meta_data_using_post(self, **kwargs):  # noqa: E501
        """Update Rule Chain Metadata  # noqa: E501

        Updates the rule chain metadata. The metadata object contains information about the rule nodes and their connections.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_meta_data_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChainMetaData body:
        :param bool update_related: Update related rule nodes.
        :return: RuleChainMetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_rule_chain_meta_data_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_rule_chain_meta_data_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_rule_chain_meta_data_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Update Rule Chain Metadata  # noqa: E501

        Updates the rule chain metadata. The metadata object contains information about the rule nodes and their connections.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_meta_data_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChainMetaData body:
        :param bool update_related: Update related rule nodes.
        :return: RuleChainMetaData
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'update_related']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_rule_chain_meta_data_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'update_related' in params:
            query_params.append(('updateRelated', params['update_related']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/metadata{?updateRelated}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChainMetaData',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_rule_chain_using_post(self, **kwargs):  # noqa: E501
        """Create Default Rule Chain  # noqa: E501

        Create rule chain from template, based on the specified name in the request. Creates the rule chain based on the template that is used to create root rule chain.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DefaultRuleChainCreateRequest body:
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_rule_chain_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_rule_chain_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_rule_chain_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create Default Rule Chain  # noqa: E501

        Create rule chain from template, based on the specified name in the request. Creates the rule chain based on the template that is used to create root rule chain.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DefaultRuleChainCreateRequest body:
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_rule_chain_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/device/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_rule_chain_using_post1(self, **kwargs):  # noqa: E501
        """Create Or Update Rule Chain (saveRuleChain)  # noqa: E501

        Create or update the Rule Chain. When creating Rule Chain, platform generates Rule Chain Id as [time-based UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_1_(date-time_and_MAC_address)). The newly created Rule Chain Id will be present in the response. Specify existing Rule Chain id to update the rule chain. Referencing non-existing rule chain Id will cause 'Not Found' error.  The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.Remove 'id', 'tenantId' from the request body example (below) to create new Rule Chain entity.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_using_post1(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChain body:
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_rule_chain_using_post1_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_rule_chain_using_post1_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_rule_chain_using_post1_with_http_info(self, **kwargs):  # noqa: E501
        """Create Or Update Rule Chain (saveRuleChain)  # noqa: E501

        Create or update the Rule Chain. When creating Rule Chain, platform generates Rule Chain Id as [time-based UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_1_(date-time_and_MAC_address)). The newly created Rule Chain Id will be present in the response. Specify existing Rule Chain id to update the rule chain. Referencing non-existing rule chain Id will cause 'Not Found' error.  The rule chain object is lightweight and contains general information about the rule chain. List of rule nodes and their connection is stored in a separate 'metadata' object.Remove 'id', 'tenantId' from the request body example (below) to create new Rule Chain entity.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_rule_chain_using_post1_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RuleChain body:
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_rule_chain_using_post1" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_auto_assign_to_edge_rule_chain_using_post(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Auto Assign To Edge Rule Chain (setAutoAssignToEdgeRuleChain)  # noqa: E501

        Makes the rule chain to be automatically assigned for any new edge that will be created. Does not assign this rule chain for already created edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_auto_assign_to_edge_rule_chain_using_post(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_auto_assign_to_edge_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_auto_assign_to_edge_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def set_auto_assign_to_edge_rule_chain_using_post_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Auto Assign To Edge Rule Chain (setAutoAssignToEdgeRuleChain)  # noqa: E501

        Makes the rule chain to be automatically assigned for any new edge that will be created. Does not assign this rule chain for already created edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_auto_assign_to_edge_rule_chain_using_post_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_auto_assign_to_edge_rule_chain_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `set_auto_assign_to_edge_rule_chain_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/autoAssignToEdge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_edge_template_root_rule_chain_using_post(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Edge Template Root Rule Chain (setEdgeTemplateRootRuleChain)  # noqa: E501

        Makes the rule chain to be root rule chain for any new edge that will be created. Does not update root rule chain for already created edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_edge_template_root_rule_chain_using_post(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_edge_template_root_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_edge_template_root_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def set_edge_template_root_rule_chain_using_post_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Edge Template Root Rule Chain (setEdgeTemplateRootRuleChain)  # noqa: E501

        Makes the rule chain to be root rule chain for any new edge that will be created. Does not update root rule chain for already created edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_edge_template_root_rule_chain_using_post_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_edge_template_root_rule_chain_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `set_edge_template_root_rule_chain_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/edgeTemplateRoot', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_root_rule_chain_using_post(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Root Rule Chain (setRootRuleChain)  # noqa: E501

        Makes the rule chain to be root rule chain. Updates previous root rule chain as well.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_root_rule_chain_using_post(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_root_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_root_rule_chain_using_post_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def set_root_rule_chain_using_post_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Set Root Rule Chain (setRootRuleChain)  # noqa: E501

        Makes the rule chain to be root rule chain. Updates previous root rule chain as well.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_root_rule_chain_using_post_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_root_rule_chain_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `set_root_rule_chain_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/root', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_script_using_post(self, **kwargs):  # noqa: E501
        """Test Script function  # noqa: E501

        Execute the Script function and return the result. The format of request:   ```json {   \"script\": \"Your Function as String\",   \"scriptType\": \"One of: update, generate, filter, switch, json, string\",   \"argNames\": [\"msg\", \"metadata\", \"type\"],   \"msg\": \"{\\\"temperature\\\": 42}\",    \"metadata\": {     \"deviceName\": \"Device A\",     \"deviceType\": \"Thermometer\"   },   \"msgType\": \"POST_TELEMETRY_REQUEST\" } ```   Expected result JSON contains \"output\" and \"error\".  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_script_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JsonNode body:
        :param str script_lang: Script language: JS or TBEL
        :return: JsonNode
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_script_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.test_script_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def test_script_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Test Script function  # noqa: E501

        Execute the Script function and return the result. The format of request:   ```json {   \"script\": \"Your Function as String\",   \"scriptType\": \"One of: update, generate, filter, switch, json, string\",   \"argNames\": [\"msg\", \"metadata\", \"type\"],   \"msg\": \"{\\\"temperature\\\": 42}\",    \"metadata\": {     \"deviceName\": \"Device A\",     \"deviceType\": \"Thermometer\"   },   \"msgType\": \"POST_TELEMETRY_REQUEST\" } ```   Expected result JSON contains \"output\" and \"error\".  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_script_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param JsonNode body:
        :param str script_lang: Script language: JS or TBEL
        :return: JsonNode
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'script_lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_script_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'script_lang' in params:
            query_params.append(('scriptLang', params['script_lang']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/testScript{?scriptLang}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonNode',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unassign_rule_chain_from_edge_using_delete(self, edge_id, rule_chain_id, **kwargs):  # noqa: E501
        """Unassign rule chain from edge (unassignRuleChainFromEdge)  # noqa: E501

        Clears assignment of the rule chain to the edge. Unassignment works in async way - first, 'unassign' notification event pushed to edge queue on platform. Second, remote edge service will receive an 'unassign' command to remove rule chain (Edge will receive this instantly, if it's currently connected, or once it's going to be connected to platform). Third, once 'unassign' command will be delivered to edge service, it's going to remove rule chain locally.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unassign_rule_chain_from_edge_using_delete(edge_id, rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: edgeId (required)
        :param str rule_chain_id: ruleChainId (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unassign_rule_chain_from_edge_using_delete_with_http_info(edge_id, rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unassign_rule_chain_from_edge_using_delete_with_http_info(edge_id, rule_chain_id, **kwargs)  # noqa: E501
            return data

    def unassign_rule_chain_from_edge_using_delete_with_http_info(self, edge_id, rule_chain_id, **kwargs):  # noqa: E501
        """Unassign rule chain from edge (unassignRuleChainFromEdge)  # noqa: E501

        Clears assignment of the rule chain to the edge. Unassignment works in async way - first, 'unassign' notification event pushed to edge queue on platform. Second, remote edge service will receive an 'unassign' command to remove rule chain (Edge will receive this instantly, if it's currently connected, or once it's going to be connected to platform). Third, once 'unassign' command will be delivered to edge service, it's going to remove rule chain locally.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unassign_rule_chain_from_edge_using_delete_with_http_info(edge_id, rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str edge_id: edgeId (required)
        :param str rule_chain_id: ruleChainId (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['edge_id', 'rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unassign_rule_chain_from_edge_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'edge_id' is set
        if ('edge_id' not in params or
                params['edge_id'] is None):
            raise ValueError("Missing the required parameter `edge_id` when calling `unassign_rule_chain_from_edge_using_delete`")  # noqa: E501
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `unassign_rule_chain_from_edge_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'edge_id' in params:
            path_params['edgeId'] = params['edge_id']  # noqa: E501
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/edge/{edgeId}/ruleChain/{ruleChainId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unset_auto_assign_to_edge_rule_chain_using_delete(self, rule_chain_id, **kwargs):  # noqa: E501
        """Unset Auto Assign To Edge Rule Chain (unsetAutoAssignToEdgeRuleChain)  # noqa: E501

        Removes the rule chain from the list of rule chains that are going to be automatically assigned for any new edge that will be created. Does not unassign this rule chain for already assigned edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unset_auto_assign_to_edge_rule_chain_using_delete(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unset_auto_assign_to_edge_rule_chain_using_delete_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unset_auto_assign_to_edge_rule_chain_using_delete_with_http_info(rule_chain_id, **kwargs)  # noqa: E501
            return data

    def unset_auto_assign_to_edge_rule_chain_using_delete_with_http_info(self, rule_chain_id, **kwargs):  # noqa: E501
        """Unset Auto Assign To Edge Rule Chain (unsetAutoAssignToEdgeRuleChain)  # noqa: E501

        Removes the rule chain from the list of rule chains that are going to be automatically assigned for any new edge that will be created. Does not unassign this rule chain for already assigned edges.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unset_auto_assign_to_edge_rule_chain_using_delete_with_http_info(rule_chain_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str rule_chain_id: A string value representing the rule chain id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: RuleChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['rule_chain_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unset_auto_assign_to_edge_rule_chain_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'rule_chain_id' is set
        if ('rule_chain_id' not in params or
                params['rule_chain_id'] is None):
            raise ValueError("Missing the required parameter `rule_chain_id` when calling `unset_auto_assign_to_edge_rule_chain_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'rule_chain_id' in params:
            path_params['ruleChainId'] = params['rule_chain_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/ruleChain/{ruleChainId}/autoAssignToEdge', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RuleChain',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
