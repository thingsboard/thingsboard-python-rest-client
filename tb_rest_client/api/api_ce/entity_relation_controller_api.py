# coding: utf-8

"""
    ThingsBoard REST API

     ThingsBoard open-source IoT platform REST API documentation.  # noqa: E501

    OpenAPI spec version: 3.5.0
    Contact: info@thingsboard.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

#  Copyright 2023. ThingsBoard
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tb_rest_client.api_client import ApiClient


class EntityRelationControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_relation_using_delete(self, from_id, from_type, relation_type, to_id, to_type, **kwargs):  # noqa: E501
        """Delete Relation (deleteRelation)  # noqa: E501

        Deletes a relation between two entities in the platform.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relation_using_delete(from_id, from_type, relation_type, to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_relation_using_delete_with_http_info(from_id, from_type, relation_type, to_id, to_type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_relation_using_delete_with_http_info(from_id, from_type, relation_type, to_id, to_type, **kwargs)  # noqa: E501
            return data

    def delete_relation_using_delete_with_http_info(self, from_id, from_type, relation_type, to_id, to_type, **kwargs):  # noqa: E501
        """Delete Relation (deleteRelation)  # noqa: E501

        Deletes a relation between two entities in the platform.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relation_using_delete_with_http_info(from_id, from_type, relation_type, to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_id', 'from_type', 'relation_type', 'to_id', 'to_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_relation_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'from_id' is set
        if ('from_id' not in params or
                params['from_id'] is None):
            raise ValueError("Missing the required parameter `from_id` when calling `delete_relation_using_delete`")  # noqa: E501
        # verify the required parameter 'from_type' is set
        if ('from_type' not in params or
                params['from_type'] is None):
            raise ValueError("Missing the required parameter `from_type` when calling `delete_relation_using_delete`")  # noqa: E501
        # verify the required parameter 'relation_type' is set
        if ('relation_type' not in params or
                params['relation_type'] is None):
            raise ValueError("Missing the required parameter `relation_type` when calling `delete_relation_using_delete`")  # noqa: E501
        # verify the required parameter 'to_id' is set
        if ('to_id' not in params or
                params['to_id'] is None):
            raise ValueError("Missing the required parameter `to_id` when calling `delete_relation_using_delete`")  # noqa: E501
        # verify the required parameter 'to_type' is set
        if ('to_type' not in params or
                params['to_type'] is None):
            raise ValueError("Missing the required parameter `to_type` when calling `delete_relation_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'from_type' in params:
            query_params.append(('fromType', params['from_type']))  # noqa: E501
        if 'relation_type' in params:
            query_params.append(('relationType', params['relation_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501
        if 'to_id' in params:
            query_params.append(('toId', params['to_id']))  # noqa: E501
        if 'to_type' in params:
            query_params.append(('toType', params['to_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relation{?fromId,fromType,relationType,relationTypeGroup,toId,toType}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_relations_using_delete(self, entity_id, entity_type, **kwargs):  # noqa: E501
        """Delete Relations (deleteRelations)  # noqa: E501

        Deletes all the relation (both 'from' and 'to' direction) for the specified entity.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relations_using_delete(entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str entity_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_relations_using_delete_with_http_info(entity_id, entity_type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_relations_using_delete_with_http_info(entity_id, entity_type, **kwargs)  # noqa: E501
            return data

    def delete_relations_using_delete_with_http_info(self, entity_id, entity_type, **kwargs):  # noqa: E501
        """Delete Relations (deleteRelations)  # noqa: E501

        Deletes all the relation (both 'from' and 'to' direction) for the specified entity.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relations_using_delete_with_http_info(entity_id, entity_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str entity_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str entity_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['entity_id', 'entity_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_relations_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'entity_id' is set
        if ('entity_id' not in params or
                params['entity_id'] is None):
            raise ValueError("Missing the required parameter `entity_id` when calling `delete_relations_using_delete`")  # noqa: E501
        # verify the required parameter 'entity_type' is set
        if ('entity_type' not in params or
                params['entity_type'] is None):
            raise ValueError("Missing the required parameter `entity_type` when calling `delete_relations_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'entity_id' in params:
            query_params.append(('entityId', params['entity_id']))  # noqa: E501
        if 'entity_type' in params:
            query_params.append(('entityType', params['entity_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations{?entityId,entityType}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_from_using_get(self, from_id, from_type, relation_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByFrom)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'from' direction and relation type.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_from_using_get(from_id, from_type, relation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_from_using_get_with_http_info(from_id, from_type, relation_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_by_from_using_get_with_http_info(from_id, from_type, relation_type, **kwargs)  # noqa: E501
            return data

    def find_by_from_using_get_with_http_info(self, from_id, from_type, relation_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByFrom)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'from' direction and relation type.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_from_using_get_with_http_info(from_id, from_type, relation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_id', 'from_type', 'relation_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_from_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'from_id' is set
        if ('from_id' not in params or
                params['from_id'] is None):
            raise ValueError("Missing the required parameter `from_id` when calling `find_by_from_using_get`")  # noqa: E501
        # verify the required parameter 'from_type' is set
        if ('from_type' not in params or
                params['from_type'] is None):
            raise ValueError("Missing the required parameter `from_type` when calling `find_by_from_using_get`")  # noqa: E501
        # verify the required parameter 'relation_type' is set
        if ('relation_type' not in params or
                params['relation_type'] is None):
            raise ValueError("Missing the required parameter `relation_type` when calling `find_by_from_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'from_type' in params:
            query_params.append(('fromType', params['from_type']))  # noqa: E501
        if 'relation_type' in params:
            query_params.append(('relationType', params['relation_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations{?fromId,fromType,relationType,relationTypeGroup}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_from_using_get1(self, from_id, from_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByFrom)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'from' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_from_using_get1(from_id, from_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_from_using_get1_with_http_info(from_id, from_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_by_from_using_get1_with_http_info(from_id, from_type, **kwargs)  # noqa: E501
            return data

    def find_by_from_using_get1_with_http_info(self, from_id, from_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByFrom)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'from' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_from_using_get1_with_http_info(from_id, from_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_id', 'from_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_from_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'from_id' is set
        if ('from_id' not in params or
                params['from_id'] is None):
            raise ValueError("Missing the required parameter `from_id` when calling `find_by_from_using_get1`")  # noqa: E501
        # verify the required parameter 'from_type' is set
        if ('from_type' not in params or
                params['from_type'] is None):
            raise ValueError("Missing the required parameter `from_type` when calling `find_by_from_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'from_type' in params:
            query_params.append(('fromType', params['from_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations{?fromId,fromType,relationTypeGroup}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_query_using_post3(self, **kwargs):  # noqa: E501
        """Find related entities (findByQuery)  # noqa: E501

        Returns all entities that are related to the specific entity. The entity id, relation type, entity types, depth of the search, and other query parameters defined using complex 'EntityRelationsQuery' object. See 'Model' tab of the Parameters for more info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_query_using_post3(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelationsQuery body:
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_query_using_post3_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_by_query_using_post3_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_by_query_using_post3_with_http_info(self, **kwargs):  # noqa: E501
        """Find related entities (findByQuery)  # noqa: E501

        Returns all entities that are related to the specific entity. The entity id, relation type, entity types, depth of the search, and other query parameters defined using complex 'EntityRelationsQuery' object. See 'Model' tab of the Parameters for more info.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_query_using_post3_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelationsQuery body:
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_query_using_post3" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_to_using_get(self, to_id, to_type, relation_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByTo)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'to' direction and relation type.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_to_using_get(to_id, to_type, relation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_to_using_get_with_http_info(to_id, to_type, relation_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_by_to_using_get_with_http_info(to_id, to_type, relation_type, **kwargs)  # noqa: E501
            return data

    def find_by_to_using_get_with_http_info(self, to_id, to_type, relation_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByTo)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'to' direction and relation type.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_to_using_get_with_http_info(to_id, to_type, relation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['to_id', 'to_type', 'relation_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_to_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'to_id' is set
        if ('to_id' not in params or
                params['to_id'] is None):
            raise ValueError("Missing the required parameter `to_id` when calling `find_by_to_using_get`")  # noqa: E501
        # verify the required parameter 'to_type' is set
        if ('to_type' not in params or
                params['to_type'] is None):
            raise ValueError("Missing the required parameter `to_type` when calling `find_by_to_using_get`")  # noqa: E501
        # verify the required parameter 'relation_type' is set
        if ('relation_type' not in params or
                params['relation_type'] is None):
            raise ValueError("Missing the required parameter `relation_type` when calling `find_by_to_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'to_id' in params:
            query_params.append(('toId', params['to_id']))  # noqa: E501
        if 'to_type' in params:
            query_params.append(('toType', params['to_type']))  # noqa: E501
        if 'relation_type' in params:
            query_params.append(('relationType', params['relation_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations{?relationType,relationTypeGroup,toId,toType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_to_using_get1(self, to_id, to_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByTo)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'to' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_to_using_get1(to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_to_using_get1_with_http_info(to_id, to_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_by_to_using_get1_with_http_info(to_id, to_type, **kwargs)  # noqa: E501
            return data

    def find_by_to_using_get1_with_http_info(self, to_id, to_type, **kwargs):  # noqa: E501
        """Get List of Relations (findByTo)  # noqa: E501

        Returns list of relation objects for the specified entity by the 'to' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_to_using_get1_with_http_info(to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelation]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['to_id', 'to_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_to_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'to_id' is set
        if ('to_id' not in params or
                params['to_id'] is None):
            raise ValueError("Missing the required parameter `to_id` when calling `find_by_to_using_get1`")  # noqa: E501
        # verify the required parameter 'to_type' is set
        if ('to_type' not in params or
                params['to_type'] is None):
            raise ValueError("Missing the required parameter `to_type` when calling `find_by_to_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'to_id' in params:
            query_params.append(('toId', params['to_id']))  # noqa: E501
        if 'to_type' in params:
            query_params.append(('toType', params['to_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations{?relationTypeGroup,toId,toType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelation]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_info_by_from_using_get(self, from_id, from_type, **kwargs):  # noqa: E501
        """Get List of Relation Infos (findInfoByFrom)  # noqa: E501

        Returns list of relation info objects for the specified entity by the 'from' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_from_using_get(from_id, from_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_info_by_from_using_get_with_http_info(from_id, from_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_info_by_from_using_get_with_http_info(from_id, from_type, **kwargs)  # noqa: E501
            return data

    def find_info_by_from_using_get_with_http_info(self, from_id, from_type, **kwargs):  # noqa: E501
        """Get List of Relation Infos (findInfoByFrom)  # noqa: E501

        Returns list of relation info objects for the specified entity by the 'from' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_from_using_get_with_http_info(from_id, from_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_id', 'from_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_info_by_from_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'from_id' is set
        if ('from_id' not in params or
                params['from_id'] is None):
            raise ValueError("Missing the required parameter `from_id` when calling `find_info_by_from_using_get`")  # noqa: E501
        # verify the required parameter 'from_type' is set
        if ('from_type' not in params or
                params['from_type'] is None):
            raise ValueError("Missing the required parameter `from_type` when calling `find_info_by_from_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'from_type' in params:
            query_params.append(('fromType', params['from_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations/info{?fromId,fromType,relationTypeGroup}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelationInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_info_by_query_using_post(self, **kwargs):  # noqa: E501
        """Find related entity infos (findInfoByQuery)  # noqa: E501

        Returns all entity infos that are related to the specific entity. The entity id, relation type, entity types, depth of the search, and other query parameters defined using complex 'EntityRelationsQuery' object. See 'Model' tab of the Parameters for more info. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_query_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelationsQuery body:
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_info_by_query_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_info_by_query_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_info_by_query_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Find related entity infos (findInfoByQuery)  # noqa: E501

        Returns all entity infos that are related to the specific entity. The entity id, relation type, entity types, depth of the search, and other query parameters defined using complex 'EntityRelationsQuery' object. See 'Model' tab of the Parameters for more info. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_query_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelationsQuery body:
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_info_by_query_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations/info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelationInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_info_by_to_using_get(self, to_id, to_type, **kwargs):  # noqa: E501
        """Get List of Relation Infos (findInfoByTo)  # noqa: E501

        Returns list of relation info objects for the specified entity by the 'to' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_to_using_get(to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_info_by_to_using_get_with_http_info(to_id, to_type, **kwargs)  # noqa: E501
        else:
            (data) = self.find_info_by_to_using_get_with_http_info(to_id, to_type, **kwargs)  # noqa: E501
            return data

    def find_info_by_to_using_get_with_http_info(self, to_id, to_type, **kwargs):  # noqa: E501
        """Get List of Relation Infos (findInfoByTo)  # noqa: E501

        Returns list of relation info objects for the specified entity by the 'to' direction.   If the user has the authority of 'System Administrator', the server checks that the entity is owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that the entity is owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the entity is assigned to the same customer. Relation Info is an extension of the default Relation object that contains information about the 'from' and 'to' entity names.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_info_by_to_using_get_with_http_info(to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: list[EntityRelationInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['to_id', 'to_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_info_by_to_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'to_id' is set
        if ('to_id' not in params or
                params['to_id'] is None):
            raise ValueError("Missing the required parameter `to_id` when calling `find_info_by_to_using_get`")  # noqa: E501
        # verify the required parameter 'to_type' is set
        if ('to_type' not in params or
                params['to_type'] is None):
            raise ValueError("Missing the required parameter `to_type` when calling `find_info_by_to_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'to_id' in params:
            query_params.append(('toId', params['to_id']))  # noqa: E501
        if 'to_type' in params:
            query_params.append(('toType', params['to_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relations/info{?relationTypeGroup,toId,toType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityRelationInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_relation_using_get(self, from_id, from_type, relation_type, to_id, to_type, **kwargs):  # noqa: E501
        """Get Relation (getRelation)  # noqa: E501

        Returns relation object between two specified entities if present. Otherwise throws exception.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_relation_using_get(from_id, from_type, relation_type, to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: EntityRelation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_relation_using_get_with_http_info(from_id, from_type, relation_type, to_id, to_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_relation_using_get_with_http_info(from_id, from_type, relation_type, to_id, to_type, **kwargs)  # noqa: E501
            return data

    def get_relation_using_get_with_http_info(self, from_id, from_type, relation_type, to_id, to_type, **kwargs):  # noqa: E501
        """Get Relation (getRelation)  # noqa: E501

        Returns relation object between two specified entities if present. Otherwise throws exception.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_relation_using_get_with_http_info(from_id, from_type, relation_type, to_id, to_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str from_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type: A string value representing relation type between entities. For example, 'Contains', 'Manages'. It can be any string value. (required)
        :param str to_id: A string value representing the entity id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param str to_type: A string value representing the entity type. For example, 'DEVICE' (required)
        :param str relation_type_group: A string value representing relation type group. For example, 'COMMON'
        :return: EntityRelation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_id', 'from_type', 'relation_type', 'to_id', 'to_type', 'relation_type_group']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_relation_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'from_id' is set
        if ('from_id' not in params or
                params['from_id'] is None):
            raise ValueError("Missing the required parameter `from_id` when calling `get_relation_using_get`")  # noqa: E501
        # verify the required parameter 'from_type' is set
        if ('from_type' not in params or
                params['from_type'] is None):
            raise ValueError("Missing the required parameter `from_type` when calling `get_relation_using_get`")  # noqa: E501
        # verify the required parameter 'relation_type' is set
        if ('relation_type' not in params or
                params['relation_type'] is None):
            raise ValueError("Missing the required parameter `relation_type` when calling `get_relation_using_get`")  # noqa: E501
        # verify the required parameter 'to_id' is set
        if ('to_id' not in params or
                params['to_id'] is None):
            raise ValueError("Missing the required parameter `to_id` when calling `get_relation_using_get`")  # noqa: E501
        # verify the required parameter 'to_type' is set
        if ('to_type' not in params or
                params['to_type'] is None):
            raise ValueError("Missing the required parameter `to_type` when calling `get_relation_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'from_type' in params:
            query_params.append(('fromType', params['from_type']))  # noqa: E501
        if 'relation_type' in params:
            query_params.append(('relationType', params['relation_type']))  # noqa: E501
        if 'relation_type_group' in params:
            query_params.append(('relationTypeGroup', params['relation_type_group']))  # noqa: E501
        if 'to_id' in params:
            query_params.append(('toId', params['to_id']))  # noqa: E501
        if 'to_type' in params:
            query_params.append(('toType', params['to_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relation{?fromId,fromType,relationType,relationTypeGroup,toId,toType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EntityRelation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_relation_using_post(self, **kwargs):  # noqa: E501
        """Create Relation (saveRelation)  # noqa: E501

        Creates or updates a relation between two entities in the platform. Relations unique key is a combination of from/to entity id and relation type group and relation type.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_relation_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelation body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_relation_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_relation_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_relation_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create Relation (saveRelation)  # noqa: E501

        Creates or updates a relation between two entities in the platform. Relations unique key is a combination of from/to entity id and relation type group and relation type.   If the user has the authority of 'System Administrator', the server checks that 'from' and 'to' entities are owned by the sysadmin. If the user has the authority of 'Tenant Administrator', the server checks that 'from' and 'to' entities are owned by the same tenant. If the user has the authority of 'Customer User', the server checks that the 'from' and 'to' entities are assigned to the same customer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_relation_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EntityRelation body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_relation_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/relation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
