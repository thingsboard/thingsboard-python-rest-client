# coding: utf-8

"""
    ThingsBoard REST API

     ThingsBoard open-source IoT platform REST API documentation.  # noqa: E501

    OpenAPI spec version: 3.5.0
    Contact: info@thingsboard.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

#  Copyright 2023. ThingsBoard
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tb_rest_client.api_client import ApiClient


class DeviceApiControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def claim_device_using_post(self, device_token, **kwargs):  # noqa: E501
        """Save claiming information (claimDevice)  # noqa: E501

        Saves the information required for user to claim the device. See more info about claiming in the corresponding 'Claiming devices' platform documentation.  Example of the request payload:   ```json {\"secretKey\":\"value\", \"durationMs\":60000} ```  Note: both 'secretKey' and 'durationMs' is optional parameters. In case the secretKey is not specified, the empty string as a default value is used. In case the durationMs is not specified, the system parameter device.claim.duration is used.  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.claim_device_using_post(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.claim_device_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.claim_device_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def claim_device_using_post_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Save claiming information (claimDevice)  # noqa: E501

        Saves the information required for user to claim the device. See more info about claiming in the corresponding 'Claiming devices' platform documentation.  Example of the request payload:   ```json {\"secretKey\":\"value\", \"durationMs\":60000} ```  Note: both 'secretKey' and 'durationMs' is optional parameters. In case the secretKey is not specified, the empty string as a default value is used. In case the durationMs is not specified, the system parameter device.claim.duration is used.  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.claim_device_using_post_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method claim_device_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `claim_device_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/claim', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_attributes_using_get(self, device_token, client_keys, shared_keys, **kwargs):  # noqa: E501
        """Get attributes (getDeviceAttributes)  # noqa: E501

        Returns all attributes that belong to device. Use optional 'clientKeys' and/or 'sharedKeys' parameter to return specific attributes.   Example of the result:   ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_attributes_using_get(device_token, client_keys, shared_keys, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str client_keys: Comma separated key names for attribute with client scope (required)
        :param str shared_keys: Comma separated key names for attribute with shared scope (required)
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_attributes_using_get_with_http_info(device_token, client_keys, shared_keys, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_attributes_using_get_with_http_info(device_token, client_keys, shared_keys, **kwargs)  # noqa: E501
            return data

    def get_device_attributes_using_get_with_http_info(self, device_token, client_keys, shared_keys, **kwargs):  # noqa: E501
        """Get attributes (getDeviceAttributes)  # noqa: E501

        Returns all attributes that belong to device. Use optional 'clientKeys' and/or 'sharedKeys' parameter to return specific attributes.   Example of the result:   ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_attributes_using_get_with_http_info(device_token, client_keys, shared_keys, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str client_keys: Comma separated key names for attribute with client scope (required)
        :param str shared_keys: Comma separated key names for attribute with shared scope (required)
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'client_keys', 'shared_keys']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_attributes_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `get_device_attributes_using_get`")  # noqa: E501
        # verify the required parameter 'client_keys' is set
        if ('client_keys' not in params or
                params['client_keys'] is None):
            raise ValueError("Missing the required parameter `client_keys` when calling `get_device_attributes_using_get`")  # noqa: E501
        # verify the required parameter 'shared_keys' is set
        if ('shared_keys' not in params or
                params['shared_keys'] is None):
            raise ValueError("Missing the required parameter `shared_keys` when calling `get_device_attributes_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []
        if 'client_keys' in params:
            query_params.append(('clientKeys', params['client_keys']))  # noqa: E501
        if 'shared_keys' in params:
            query_params.append(('sharedKeys', params['shared_keys']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/attributes{?clientKeys,sharedKeys}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_firmware_using_get(self, device_token, title, version, **kwargs):  # noqa: E501
        """Get Device Firmware (getFirmware)  # noqa: E501

        Downloads the current firmware package.When the platform initiates firmware update, it informs the device by updating the 'fw_title', 'fw_version', 'fw_checksum' and 'fw_checksum_algorithm' shared attributes.The 'fw_title' and 'fw_version' parameters must be supplied in this request to double-check that the firmware that device is downloading matches the firmware it expects to download. This is important, since the administrator may change the firmware assignment while device is downloading the firmware.   Optional 'chunk' and 'size' parameters may be used to download the firmware in chunks. For example, device may request first 16 KB of firmware using 'chunk'=0 and 'size'=16384. Next 16KB using 'chunk'=1 and 'size'=16384. The last chunk should have less bytes then requested using 'size' parameter.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firmware_using_get(device_token, title, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str title: Title of the firmware, corresponds to the value of 'fw_title' attribute. (required)
        :param str version: Version of the firmware, corresponds to the value of 'fw_version' attribute. (required)
        :param int size: Size of the chunk. Optional. Omit to download the entire file without chunks.
        :param int chunk: Index of the chunk. Optional. Omit to download the entire file without chunks.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_firmware_using_get_with_http_info(device_token, title, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_firmware_using_get_with_http_info(device_token, title, version, **kwargs)  # noqa: E501
            return data

    def get_firmware_using_get_with_http_info(self, device_token, title, version, **kwargs):  # noqa: E501
        """Get Device Firmware (getFirmware)  # noqa: E501

        Downloads the current firmware package.When the platform initiates firmware update, it informs the device by updating the 'fw_title', 'fw_version', 'fw_checksum' and 'fw_checksum_algorithm' shared attributes.The 'fw_title' and 'fw_version' parameters must be supplied in this request to double-check that the firmware that device is downloading matches the firmware it expects to download. This is important, since the administrator may change the firmware assignment while device is downloading the firmware.   Optional 'chunk' and 'size' parameters may be used to download the firmware in chunks. For example, device may request first 16 KB of firmware using 'chunk'=0 and 'size'=16384. Next 16KB using 'chunk'=1 and 'size'=16384. The last chunk should have less bytes then requested using 'size' parameter.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_firmware_using_get_with_http_info(device_token, title, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str title: Title of the firmware, corresponds to the value of 'fw_title' attribute. (required)
        :param str version: Version of the firmware, corresponds to the value of 'fw_version' attribute. (required)
        :param int size: Size of the chunk. Optional. Omit to download the entire file without chunks.
        :param int chunk: Index of the chunk. Optional. Omit to download the entire file without chunks.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'title', 'version', 'size', 'chunk']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_firmware_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `get_firmware_using_get`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `get_firmware_using_get`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_firmware_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'chunk' in params:
            query_params.append(('chunk', params['chunk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/firmware{?chunk,size,title,version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_software_using_get(self, device_token, title, version, **kwargs):  # noqa: E501
        """Get Device Software (getSoftware)  # noqa: E501

        Downloads the current software package.When the platform initiates software update, it informs the device by updating the 'sw_title', 'sw_version', 'sw_checksum' and 'sw_checksum_algorithm' shared attributes.The 'sw_title' and 'sw_version' parameters must be supplied in this request to double-check that the software that device is downloading matches the software it expects to download. This is important, since the administrator may change the software assignment while device is downloading the software.   Optional 'chunk' and 'size' parameters may be used to download the software in chunks. For example, device may request first 16 KB of software using 'chunk'=0 and 'size'=16384. Next 16KB using 'chunk'=1 and 'size'=16384. The last chunk should have less bytes then requested using 'size' parameter.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_using_get(device_token, title, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str title: Title of the software, corresponds to the value of 'sw_title' attribute. (required)
        :param str version: Version of the software, corresponds to the value of 'sw_version' attribute. (required)
        :param int size: Size of the chunk. Optional. Omit to download the entire file without using  chunks.
        :param int chunk: Index of the chunk. Optional. Omit to download the entire file without using chunks.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_software_using_get_with_http_info(device_token, title, version, **kwargs)  # noqa: E501
        else:
            (data) = self.get_software_using_get_with_http_info(device_token, title, version, **kwargs)  # noqa: E501
            return data

    def get_software_using_get_with_http_info(self, device_token, title, version, **kwargs):  # noqa: E501
        """Get Device Software (getSoftware)  # noqa: E501

        Downloads the current software package.When the platform initiates software update, it informs the device by updating the 'sw_title', 'sw_version', 'sw_checksum' and 'sw_checksum_algorithm' shared attributes.The 'sw_title' and 'sw_version' parameters must be supplied in this request to double-check that the software that device is downloading matches the software it expects to download. This is important, since the administrator may change the software assignment while device is downloading the software.   Optional 'chunk' and 'size' parameters may be used to download the software in chunks. For example, device may request first 16 KB of software using 'chunk'=0 and 'size'=16384. Next 16KB using 'chunk'=1 and 'size'=16384. The last chunk should have less bytes then requested using 'size' parameter.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_software_using_get_with_http_info(device_token, title, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str title: Title of the software, corresponds to the value of 'sw_title' attribute. (required)
        :param str version: Version of the software, corresponds to the value of 'sw_version' attribute. (required)
        :param int size: Size of the chunk. Optional. Omit to download the entire file without using  chunks.
        :param int chunk: Index of the chunk. Optional. Omit to download the entire file without using chunks.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'title', 'version', 'size', 'chunk']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_software_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `get_software_using_get`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `get_software_using_get`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_software_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'chunk' in params:
            query_params.append(('chunk', params['chunk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/software{?chunk,size,title,version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_device_attributes_using_post(self, device_token, **kwargs):  # noqa: E501
        """Post attributes (postDeviceAttributes)  # noqa: E501

        Post client attribute updates on behalf of device.   Example of the request:   ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_device_attributes_using_post(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_device_attributes_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.post_device_attributes_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def post_device_attributes_using_post_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Post attributes (postDeviceAttributes)  # noqa: E501

        Post client attribute updates on behalf of device.   Example of the request:   ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_device_attributes_using_post_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_device_attributes_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `post_device_attributes_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/attributes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_rpc_request_using_post(self, device_token, **kwargs):  # noqa: E501
        """Send the RPC command (postRpcRequest)  # noqa: E501

        Send the RPC request to server. The request payload is a JSON document that contains 'method' and 'params'. For example:  ```json {\"method\": \"sumOnServer\", \"params\":{\"a\":2, \"b\":2}} ```  The response contains arbitrary JSON with the RPC reply. For example:   ```json {\"result\": 4} ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_rpc_request_using_post(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_rpc_request_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.post_rpc_request_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def post_rpc_request_using_post_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Send the RPC command (postRpcRequest)  # noqa: E501

        Send the RPC request to server. The request payload is a JSON document that contains 'method' and 'params'. For example:  ```json {\"method\": \"sumOnServer\", \"params\":{\"a\":2, \"b\":2}} ```  The response contains arbitrary JSON with the RPC reply. For example:   ```json {\"result\": 4} ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_rpc_request_using_post_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_rpc_request_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `post_rpc_request_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/rpc', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_telemetry_using_post(self, device_token, **kwargs):  # noqa: E501
        """Post time-series data (postTelemetry)  # noqa: E501

        Post time-series data on behalf of device.   Example of the request: The request payload is a JSON document with three possible formats:  Simple format without timestamp. In such a case, current server time will be used:     ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```     Single JSON object with timestamp:     ```json {\"ts\":1634712287000,\"values\":{\"temperature\":26, \"humidity\":87}} ```     JSON array with timestamps:     ```json [ {\"ts\":1634712287000,\"values\":{\"temperature\":26, \"humidity\":87}},  {\"ts\":1634712588000,\"values\":{\"temperature\":25, \"humidity\":88}} ] ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_telemetry_using_post(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_telemetry_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.post_telemetry_using_post_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def post_telemetry_using_post_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Post time-series data (postTelemetry)  # noqa: E501

        Post time-series data on behalf of device.   Example of the request: The request payload is a JSON document with three possible formats:  Simple format without timestamp. In such a case, current server time will be used:     ```json {  \"stringKey\":\"value1\",   \"booleanKey\":true,   \"doubleKey\":42.0,   \"longKey\":73,   \"jsonKey\": {     \"someNumber\": 42,     \"someArray\": [1,2,3],     \"someNestedObject\": {\"key\": \"value\"}  } } ```     Single JSON object with timestamp:     ```json {\"ts\":1634712287000,\"values\":{\"temperature\":26, \"humidity\":87}} ```     JSON array with timestamps:     ```json [ {\"ts\":1634712287000,\"values\":{\"temperature\":26, \"humidity\":87}},  {\"ts\":1634712588000,\"values\":{\"temperature\":25, \"humidity\":88}} ] ```  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_telemetry_using_post_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_telemetry_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `post_telemetry_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/telemetry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def provision_device_using_post(self, **kwargs):  # noqa: E501
        """Provision new device (provisionDevice)  # noqa: E501

        Exchange the provision request to the device credentials. See more info about provisioning in the corresponding 'Device provisioning' platform documentation.Requires valid JSON request with the following format:   ```json {   \"deviceName\": \"NEW_DEVICE_NAME\",   \"provisionDeviceKey\": \"u7piawkboq8v32dmcmpp\",   \"provisionDeviceSecret\": \"jpmwdn8ptlswmf4m29bw\" } ```  Where 'deviceName' is the name of enw or existing device which depends on the provisioning strategy. The 'provisionDeviceKey' and 'provisionDeviceSecret' matches info configured in one of the existing device profiles. The result of the successful call is the JSON object that contains new credentials:  ```json {   \"credentialsType\":\"ACCESS_TOKEN\",   \"credentialsValue\":\"DEVICE_ACCESS_TOKEN\",   \"status\":\"SUCCESS\" } ```    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provision_device_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.provision_device_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.provision_device_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def provision_device_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Provision new device (provisionDevice)  # noqa: E501

        Exchange the provision request to the device credentials. See more info about provisioning in the corresponding 'Device provisioning' platform documentation.Requires valid JSON request with the following format:   ```json {   \"deviceName\": \"NEW_DEVICE_NAME\",   \"provisionDeviceKey\": \"u7piawkboq8v32dmcmpp\",   \"provisionDeviceSecret\": \"jpmwdn8ptlswmf4m29bw\" } ```  Where 'deviceName' is the name of enw or existing device which depends on the provisioning strategy. The 'provisionDeviceKey' and 'provisionDeviceSecret' matches info configured in one of the existing device profiles. The result of the successful call is the JSON object that contains new credentials:  ```json {   \"credentialsType\":\"ACCESS_TOKEN\",   \"credentialsValue\":\"DEVICE_ACCESS_TOKEN\",   \"status\":\"SUCCESS\" } ```    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provision_device_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method provision_device_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/provision', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reply_to_command_using_post(self, device_token, request_id, **kwargs):  # noqa: E501
        """Reply to RPC commands (replyToCommand)  # noqa: E501

        Replies to server originated RPC command identified by 'requestId' parameter. The response is arbitrary JSON.  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_to_command_using_post(device_token, request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int request_id: RPC request id from the incoming RPC request (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reply_to_command_using_post_with_http_info(device_token, request_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reply_to_command_using_post_with_http_info(device_token, request_id, **kwargs)  # noqa: E501
            return data

    def reply_to_command_using_post_with_http_info(self, device_token, request_id, **kwargs):  # noqa: E501
        """Reply to RPC commands (replyToCommand)  # noqa: E501

        Replies to server originated RPC command identified by 'requestId' parameter. The response is arbitrary JSON.  The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_to_command_using_post_with_http_info(device_token, request_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int request_id: RPC request id from the incoming RPC request (required)
        :param str body:
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'request_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reply_to_command_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `reply_to_command_using_post`")  # noqa: E501
        # verify the required parameter 'request_id' is set
        if ('request_id' not in params or
                params['request_id'] is None):
            raise ValueError("Missing the required parameter `request_id` when calling `reply_to_command_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501
        if 'request_id' in params:
            path_params['requestId'] = params['request_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/rpc/{requestId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_to_attributes_using_get(self, device_token, **kwargs):  # noqa: E501
        """Subscribe to attribute updates (subscribeToAttributes) (Deprecated)  # noqa: E501

        Subscribes to client and shared scope attribute updates using http long polling. Deprecated, since long polling is resource and network consuming. Consider using MQTT or CoAP protocol for light-weight real-time updates.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_attributes_using_get(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int timeout: Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_to_attributes_using_get_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_to_attributes_using_get_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def subscribe_to_attributes_using_get_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Subscribe to attribute updates (subscribeToAttributes) (Deprecated)  # noqa: E501

        Subscribes to client and shared scope attribute updates using http long polling. Deprecated, since long polling is resource and network consuming. Consider using MQTT or CoAP protocol for light-weight real-time updates.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_attributes_using_get_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int timeout: Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'timeout']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_to_attributes_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `subscribe_to_attributes_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []
        if 'timeout' in params:
            query_params.append(('timeout', params['timeout']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/attributes/updates{?timeout}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_to_commands_using_get(self, device_token, **kwargs):  # noqa: E501
        """Subscribe to RPC commands (subscribeToCommands) (Deprecated)  # noqa: E501

        Subscribes to RPC commands using http long polling. Deprecated, since long polling is resource and network consuming. Consider using MQTT or CoAP protocol for light-weight real-time updates.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_commands_using_get(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int timeout: Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_to_commands_using_get_with_http_info(device_token, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_to_commands_using_get_with_http_info(device_token, **kwargs)  # noqa: E501
            return data

    def subscribe_to_commands_using_get_with_http_info(self, device_token, **kwargs):  # noqa: E501
        """Subscribe to RPC commands (subscribeToCommands) (Deprecated)  # noqa: E501

        Subscribes to RPC commands using http long polling. Deprecated, since long polling is resource and network consuming. Consider using MQTT or CoAP protocol for light-weight real-time updates.   The API call is designed to be used by device firmware and requires device access token ('deviceToken'). It is not recommended to use this API call by third-party scripts, rule-engine or platform widgets (use 'Telemetry Controller' instead).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_to_commands_using_get_with_http_info(device_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_token: Your device access token. (required)
        :param int timeout: Optional timeout of the long poll. Typically less then 60 seconds, since limited on the server side.
        :return: DeferredResultResponseEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_token', 'timeout']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_to_commands_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_token' is set
        if ('device_token' not in params or
                params['device_token'] is None):
            raise ValueError("Missing the required parameter `device_token` when calling `subscribe_to_commands_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_token' in params:
            path_params['deviceToken'] = params['device_token']  # noqa: E501

        query_params = []
        if 'timeout' in params:
            query_params.append(('timeout', params['timeout']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v1/{deviceToken}/rpc{?timeout}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeferredResultResponseEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
