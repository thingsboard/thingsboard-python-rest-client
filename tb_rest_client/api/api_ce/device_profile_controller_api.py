# coding: utf-8

"""
    ThingsBoard REST API

     ThingsBoard open-source IoT platform REST API documentation.  # noqa: E501

    OpenAPI spec version: 3.9.0
    Contact: info@thingsboard.io
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

#  Copyright 2025. ThingsBoard
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tb_rest_client.api_client import ApiClient


class DeviceProfileControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_device_profile_using_delete(self, device_profile_id, **kwargs):  # noqa: E501
        """Delete device profile (deleteDeviceProfile)  # noqa: E501

        Deletes the device profile. Referencing non-existing device profile Id will cause an error. Can't delete the device profile if it is referenced by existing devices.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_profile_using_delete(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_profile_using_delete_with_http_info(device_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_profile_using_delete_with_http_info(device_profile_id, **kwargs)  # noqa: E501
            return data

    def delete_device_profile_using_delete_with_http_info(self, device_profile_id, **kwargs):  # noqa: E501
        """Delete device profile (deleteDeviceProfile)  # noqa: E501

        Deletes the device profile. Referencing non-existing device profile Id will cause an error. Can't delete the device profile if it is referenced by existing devices.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_profile_using_delete_with_http_info(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_profile_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_profile_id' is set
        if ('device_profile_id' not in params or
                params['device_profile_id'] is None):
            raise ValueError("Missing the required parameter `device_profile_id` when calling `delete_device_profile_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_profile_id' in params:
            path_params['deviceProfileId'] = params['device_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/{deviceProfileId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attributes_keys_using_get(self, **kwargs):  # noqa: E501
        """Get attribute keys (getAttributesKeys)  # noqa: E501

        Get a set of unique attribute keys used by devices that belong to specified profile. If profile is not set returns a list of unique keys among all profiles. The call is used for auto-complete in the UI forms. The implementation limits the number of devices that participate in search to 100 as a trade of between accurate results and time-consuming queries.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes_keys_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_attributes_keys_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_attributes_keys_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_attributes_keys_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get attribute keys (getAttributesKeys)  # noqa: E501

        Get a set of unique attribute keys used by devices that belong to specified profile. If profile is not set returns a list of unique keys among all profiles. The call is used for auto-complete in the UI forms. The implementation limits the number of devices that participate in search to 100 as a trade of between accurate results and time-consuming queries.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes_keys_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attributes_keys_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_profile_id' in params:
            query_params.append(('deviceProfileId', params['device_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/devices/keys/attributes{?deviceProfileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_default_device_profile_info_using_get(self, **kwargs):  # noqa: E501
        """Get Default Device Profile (getDefaultDeviceProfileInfo)  # noqa: E501

        Fetch the Default Device Profile Info object. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_device_profile_info_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_default_device_profile_info_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_default_device_profile_info_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_default_device_profile_info_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Default Device Profile (getDefaultDeviceProfileInfo)  # noqa: E501

        Fetch the Default Device Profile Info object. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_default_device_profile_info_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: DeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_default_device_profile_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfileInfo/default', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceProfileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_profile_by_id_using_get(self, device_profile_id, **kwargs):  # noqa: E501
        """Get Device Profile (getDeviceProfileById)  # noqa: E501

        Fetch the Device Profile object based on the provided Device Profile Id. The server checks that the device profile is owned by the same tenant.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_by_id_using_get(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param bool inline_images: Inline images as a data URL (Base64)
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_profile_by_id_using_get_with_http_info(device_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_profile_by_id_using_get_with_http_info(device_profile_id, **kwargs)  # noqa: E501
            return data

    def get_device_profile_by_id_using_get_with_http_info(self, device_profile_id, **kwargs):  # noqa: E501
        """Get Device Profile (getDeviceProfileById)  # noqa: E501

        Fetch the Device Profile object based on the provided Device Profile Id. The server checks that the device profile is owned by the same tenant.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_by_id_using_get_with_http_info(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :param bool inline_images: Inline images as a data URL (Base64)
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id', 'inline_images']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_profile_by_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_profile_id' is set
        if ('device_profile_id' not in params or
                params['device_profile_id'] is None):
            raise ValueError("Missing the required parameter `device_profile_id` when calling `get_device_profile_by_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_profile_id' in params:
            path_params['deviceProfileId'] = params['device_profile_id']  # noqa: E501

        query_params = []
        if 'inline_images' in params:
            query_params.append(('inlineImages', params['inline_images']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/{deviceProfileId}{?inlineImages}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_profile_info_by_id_using_get(self, device_profile_id, **kwargs):  # noqa: E501
        """Get Device Profile Info (getDeviceProfileInfoById)  # noqa: E501

        Fetch the Device Profile Info object based on the provided Device Profile Id. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_info_by_id_using_get(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: DeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_profile_info_by_id_using_get_with_http_info(device_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_profile_info_by_id_using_get_with_http_info(device_profile_id, **kwargs)  # noqa: E501
            return data

    def get_device_profile_info_by_id_using_get_with_http_info(self, device_profile_id, **kwargs):  # noqa: E501
        """Get Device Profile Info (getDeviceProfileInfoById)  # noqa: E501

        Fetch the Device Profile Info object based on the provided Device Profile Id. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_info_by_id_using_get_with_http_info(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: DeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_profile_info_by_id_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_profile_id' is set
        if ('device_profile_id' not in params or
                params['device_profile_id'] is None):
            raise ValueError("Missing the required parameter `device_profile_id` when calling `get_device_profile_info_by_id_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_profile_id' in params:
            path_params['deviceProfileId'] = params['device_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfileInfo/{deviceProfileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceProfileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_profile_infos_using_get(self, page_size, page, **kwargs):  # noqa: E501
        """Get Device Profiles for transport type (getDeviceProfileInfos)  # noqa: E501

        Returns a page of devices profile info objects owned by tenant. You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_infos_using_get(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the device profile name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :param str transport_type: Type of the transport
        :return: PageDataDeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_profile_infos_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_profile_infos_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
            return data

    def get_device_profile_infos_using_get_with_http_info(self, page_size, page, **kwargs):  # noqa: E501
        """Get Device Profiles for transport type (getDeviceProfileInfos)  # noqa: E501

        Returns a page of devices profile info objects owned by tenant. You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details. Device Profile Info is a lightweight object that includes main information about Device Profile excluding the heavyweight configuration object.   Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_infos_using_get_with_http_info(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the device profile name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :param str transport_type: Type of the transport
        :return: PageDataDeviceProfileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'page', 'text_search', 'sort_property', 'sort_order', 'transport_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_profile_infos_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_size' is set
        if ('page_size' not in params or
                params['page_size'] is None):
            raise ValueError("Missing the required parameter `page_size` when calling `get_device_profile_infos_using_get`")  # noqa: E501
        # verify the required parameter 'page' is set
        if ('page' not in params or
                params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `get_device_profile_infos_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'text_search' in params:
            query_params.append(('textSearch', params['text_search']))  # noqa: E501
        if 'sort_property' in params:
            query_params.append(('sortProperty', params['sort_property']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501
        if 'transport_type' in params:
            query_params.append(('transportType', params['transport_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfileInfos{?page,pageSize,sortOrder,sortProperty,textSearch,transportType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageDataDeviceProfileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_profile_names_using_get(self, **kwargs):  # noqa: E501
        """Get Device Profile names (getDeviceProfileNames)  # noqa: E501

        Returns a set of unique device profile names owned by the tenant.  Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_names_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool active_only: Flag indicating whether to retrieve exclusively the names of device profiles that are referenced by tenant's devices.
        :return: list[EntityInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_profile_names_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_device_profile_names_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_device_profile_names_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Device Profile names (getDeviceProfileNames)  # noqa: E501

        Returns a set of unique device profile names owned by the tenant.  Available for users with 'TENANT_ADMIN' or 'CUSTOMER_USER' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profile_names_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool active_only: Flag indicating whether to retrieve exclusively the names of device profiles that are referenced by tenant's devices.
        :return: list[EntityInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['active_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_profile_names_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'active_only' in params:
            query_params.append(('activeOnly', params['active_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/names{?activeOnly}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EntityInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_profiles_using_get(self, page_size, page, **kwargs):  # noqa: E501
        """Get Device Profiles (getDeviceProfiles)  # noqa: E501

        Returns a page of devices profile objects owned by tenant. You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profiles_using_get(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the device profile name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataDeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_profiles_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_profiles_using_get_with_http_info(page_size, page, **kwargs)  # noqa: E501
            return data

    def get_device_profiles_using_get_with_http_info(self, page_size, page, **kwargs):  # noqa: E501
        """Get Device Profiles (getDeviceProfiles)  # noqa: E501

        Returns a page of devices profile objects owned by tenant. You can specify parameters to filter the results. The result is wrapped with PageData object that allows you to iterate over result set using pagination. See the 'Model' tab of the Response Class for more details.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_profiles_using_get_with_http_info(page_size, page, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: Maximum amount of entities in a one page (required)
        :param int page: Sequence number of page starting from 0 (required)
        :param str text_search: The case insensitive 'substring' filter based on the device profile name.
        :param str sort_property: Property of entity to sort by
        :param str sort_order: Sort order. ASC (ASCENDING) or DESC (DESCENDING)
        :return: PageDataDeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'page', 'text_search', 'sort_property', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_profiles_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'page_size' is set
        if ('page_size' not in params or
                params['page_size'] is None):
            raise ValueError("Missing the required parameter `page_size` when calling `get_device_profiles_using_get`")  # noqa: E501
        # verify the required parameter 'page' is set
        if ('page' not in params or
                params['page'] is None):
            raise ValueError("Missing the required parameter `page` when calling `get_device_profiles_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'text_search' in params:
            query_params.append(('textSearch', params['text_search']))  # noqa: E501
        if 'sort_property' in params:
            query_params.append(('sortProperty', params['sort_property']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfiles{?page,pageSize,sortOrder,sortProperty,textSearch}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageDataDeviceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_timeseries_keys_using_get(self, **kwargs):  # noqa: E501
        """Get time-series keys (getTimeseriesKeys)  # noqa: E501

        Get a set of unique time-series keys used by devices that belong to specified profile. If profile is not set returns a list of unique keys among all profiles. The call is used for auto-complete in the UI forms. The implementation limits the number of devices that participate in search to 100 as a trade of between accurate results and time-consuming queries.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_timeseries_keys_using_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_timeseries_keys_using_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_timeseries_keys_using_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_timeseries_keys_using_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get time-series keys (getTimeseriesKeys)  # noqa: E501

        Get a set of unique time-series keys used by devices that belong to specified profile. If profile is not set returns a list of unique keys among all profiles. The call is used for auto-complete in the UI forms. The implementation limits the number of devices that participate in search to 100 as a trade of between accurate results and time-consuming queries.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_timeseries_keys_using_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9'
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timeseries_keys_using_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'device_profile_id' in params:
            query_params.append(('deviceProfileId', params['device_profile_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/devices/keys/timeseries{?deviceProfileId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_device_profile_using_post(self, **kwargs):  # noqa: E501
        """Create Or Update Device Profile (saveDeviceProfile)  # noqa: E501

        Create or update the Device Profile. When creating device profile, platform generates device profile id as [time-based UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_1_(date-time_and_MAC_address)). The newly created device profile id will be present in the response. Specify existing device profile id to update the device profile. Referencing non-existing device profile Id will cause 'Not Found' error.   Device profile name is unique in the scope of tenant. Only one 'default' device profile may exist in scope of tenant.  # Device profile data definition  Device profile data object contains alarm rules configuration, device provision strategy and transport type configuration for device connectivity. Let's review some examples. First one is the default device profile data configuration and second one - the custom one.   ```json {    \"alarms\":[    ],    \"configuration\":{       \"type\":\"DEFAULT\"    },    \"provisionConfiguration\":{       \"type\":\"DISABLED\",       \"provisionDeviceSecret\":null    },    \"transportConfiguration\":{       \"type\":\"DEFAULT\"    } } ```  ```json {    \"alarms\":[       {          \"id\":\"2492b935-1226-59e9-8615-17d8978a4f93\",          \"alarmType\":\"Temperature Alarm\",          \"clearRule\":{             \"schedule\":null,             \"condition\":{                \"spec\":{                   \"type\":\"SIMPLE\"                },                \"condition\":[                   {                      \"key\":{                         \"key\":\"temperature\",                         \"type\":\"TIME_SERIES\"                      },                      \"value\":null,                      \"predicate\":{                         \"type\":\"NUMERIC\",                         \"value\":{                            \"userValue\":null,                            \"defaultValue\":30.0,                            \"dynamicValue\":null                         },                         \"operation\":\"LESS\"                      },                      \"valueType\":\"NUMERIC\"                   }                ]             },             \"dashboardId\":null,             \"alarmDetails\":null          },          \"propagate\":false,          \"createRules\":{             \"MAJOR\":{                \"schedule\":{                   \"type\":\"SPECIFIC_TIME\",                   \"endsOn\":64800000,                   \"startsOn\":43200000,                   \"timezone\":\"Europe/Kiev\",                   \"daysOfWeek\":[                      1,                      3,                      5                   ]                },                \"condition\":{                   \"spec\":{                      \"type\":\"DURATION\",                      \"unit\":\"MINUTES\",                      \"predicate\":{                         \"userValue\":null,                         \"defaultValue\":30,                         \"dynamicValue\":null                      }                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"temperature\",                            \"type\":\"TIME_SERIES\"                         },                         \"value\":null,                         \"predicate\":{                            \"type\":\"COMPLEX\",                            \"operation\":\"OR\",                            \"predicates\":[                               {                                  \"type\":\"NUMERIC\",                                  \"value\":{                                     \"userValue\":null,                                     \"defaultValue\":50.0,                                     \"dynamicValue\":null                                  },                                  \"operation\":\"LESS_OR_EQUAL\"                               },                               {                                  \"type\":\"NUMERIC\",                                  \"value\":{                                     \"userValue\":null,                                     \"defaultValue\":30.0,                                     \"dynamicValue\":null                                  },                                  \"operation\":\"GREATER\"                               }                            ]                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             },             \"WARNING\":{                \"schedule\":{                   \"type\":\"CUSTOM\",                   \"items\":[                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":1                      },                      {                         \"endsOn\":64800000,                         \"enabled\":true,                         \"startsOn\":43200000,                         \"dayOfWeek\":2                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":3                      },                      {                         \"endsOn\":57600000,                         \"enabled\":true,                         \"startsOn\":36000000,                         \"dayOfWeek\":4                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":5                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":6                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":7                      }                   ],                   \"timezone\":\"Europe/Kiev\"                },                \"condition\":{                   \"spec\":{                      \"type\":\"REPEATING\",                      \"predicate\":{                         \"userValue\":null,                         \"defaultValue\":5,                         \"dynamicValue\":null                      }                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"tempConstant\",                            \"type\":\"CONSTANT\"                         },                         \"value\":30,                         \"predicate\":{                            \"type\":\"NUMERIC\",                            \"value\":{                               \"userValue\":null,                               \"defaultValue\":0.0,                               \"dynamicValue\":{                                  \"inherit\":false,                                  \"sourceType\":\"CURRENT_DEVICE\",                                  \"sourceAttribute\":\"tempThreshold\"                               }                            },                            \"operation\":\"EQUAL\"                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             },             \"CRITICAL\":{                \"schedule\":null,                \"condition\":{                   \"spec\":{                      \"type\":\"SIMPLE\"                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"temperature\",                            \"type\":\"TIME_SERIES\"                         },                         \"value\":null,                         \"predicate\":{                            \"type\":\"NUMERIC\",                            \"value\":{                               \"userValue\":null,                               \"defaultValue\":50.0,                               \"dynamicValue\":null                            },                            \"operation\":\"GREATER\"                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             }          },          \"propagateRelationTypes\":null       }    ],    \"configuration\":{       \"type\":\"DEFAULT\"    },    \"provisionConfiguration\":{       \"type\":\"ALLOW_CREATE_NEW_DEVICES\",       \"provisionDeviceSecret\":\"vaxb9hzqdbz3oqukvomg\"    },    \"transportConfiguration\":{       \"type\":\"MQTT\",       \"deviceTelemetryTopic\":\"v1/devices/me/telemetry\",       \"deviceAttributesTopic\":\"v1/devices/me/attributes\",       \"transportPayloadTypeConfiguration\":{          \"transportPayloadType\":\"PROTOBUF\",          \"deviceTelemetryProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage telemetry;\\n\\nmessage SensorDataReading {\\n\\n  optional double temperature = 1;\\n  optional double humidity = 2;\\n  InnerObject innerObject = 3;\\n\\n  message InnerObject {\\n    optional string key1 = 1;\\n    optional bool key2 = 2;\\n    optional double key3 = 3;\\n    optional int32 key4 = 4;\\n    optional string key5 = 5;\\n  }\\n}\",          \"deviceAttributesProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage attributes;\\n\\nmessage SensorConfiguration {\\n  optional string firmwareVersion = 1;\\n  optional string serialNumber = 2;\\n}\",          \"deviceRpcRequestProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage rpc;\\n\\nmessage RpcRequestMsg {\\n  optional string method = 1;\\n  optional int32 requestId = 2;\\n  optional string params = 3;\\n}\",          \"deviceRpcResponseProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage rpc;\\n\\nmessage RpcResponseMsg {\\n  optional string payload = 1;\\n}\"       }    } } ```  Let's review some specific objects examples related to the device profile configuration:  # Alarm Schedule  Alarm Schedule JSON object represents the time interval during which the alarm rule is active. Note,   ```json \"schedule\": null ```  means alarm rule is active all the time. **'daysOfWeek'** field represents Monday as 1, Tuesday as 2 and so on. **'startsOn'** and **'endsOn'** fields represent hours in millis (e.g. 64800000 = 18:00 or 6pm). **'enabled'** flag specifies if item in a custom rule is active for specific day of the week:  ## Specific Time Schedule  ```json {    \"schedule\":{       \"type\":\"SPECIFIC_TIME\",       \"endsOn\":64800000,       \"startsOn\":43200000,       \"timezone\":\"Europe/Kiev\",       \"daysOfWeek\":[          1,          3,          5       ]    } } ```  ## Custom Schedule  ```json {    \"schedule\":{       \"type\":\"CUSTOM\",       \"items\":[          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":1          },          {             \"endsOn\":64800000,             \"enabled\":true,             \"startsOn\":43200000,             \"dayOfWeek\":2          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":3          },          {             \"endsOn\":57600000,             \"enabled\":true,             \"startsOn\":36000000,             \"dayOfWeek\":4          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":5          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":6          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":7          }       ],       \"timezone\":\"Europe/Kiev\"    } } ```  # Alarm condition type (**'spec'**)  Alarm condition type can be either simple, duration, or repeating. For example, 5 times in a row or during 5 minutes.  Note, **'userValue'** field is not used and reserved for future usage, **'dynamicValue'** is used for condition appliance by using the value of the **'sourceAttribute'** or else **'defaultValue'** is used (if **'sourceAttribute'** is absent).  **'sourceType'** of the **'sourceAttribute'** can be:   * 'CURRENT_DEVICE';  * 'CURRENT_CUSTOMER';  * 'CURRENT_TENANT'.  **'sourceAttribute'** can be inherited from the owner if **'inherit'** is set to true (for CURRENT_DEVICE and CURRENT_CUSTOMER).  ## Repeating alarm condition  ```json {    \"spec\":{       \"type\":\"REPEATING\",       \"predicate\":{          \"userValue\":null,          \"defaultValue\":5,          \"dynamicValue\":{             \"inherit\":true,             \"sourceType\":\"CURRENT_DEVICE\",             \"sourceAttribute\":\"tempAttr\"          }       }    } } ```  ## Duration alarm condition  ```json {    \"spec\":{       \"type\":\"DURATION\",       \"unit\":\"MINUTES\",       \"predicate\":{          \"userValue\":null,          \"defaultValue\":30,          \"dynamicValue\":null       }    } } ```  **'unit'** can be:   * 'SECONDS';  * 'MINUTES';  * 'HOURS';  * 'DAYS'.  # Key Filters  Key filter objects are created under the **'condition'** array. They allow you to define complex logical expressions over entity field, attribute, latest time-series value or constant. The filter is defined using 'key', 'valueType', 'value' (refers to the value of the 'CONSTANT' alarm filter key type) and 'predicate' objects. Let's review each object:  ## Alarm Filter Key  Filter Key defines either entity field, attribute, telemetry or constant. It is a JSON object that consists the key name and type. The following filter key types are supported:  * 'ATTRIBUTE' - used for attributes values;  * 'TIME_SERIES' - used for time-series values;  * 'ENTITY_FIELD' - used for accessing entity fields like 'name', 'label', etc. The list of available fields depends on the entity type;  * 'CONSTANT' - constant value specified.  Let's review the example:  ```json {   \"type\": \"TIME_SERIES\",   \"key\": \"temperature\" } ```  ## Value Type and Operations  Provides a hint about the data type of the entity field that is defined in the filter key. The value type impacts the list of possible operations that you may use in the corresponding predicate. For example, you may use 'STARTS_WITH' or 'END_WITH', but you can't use 'GREATER_OR_EQUAL' for string values.The following filter value types and corresponding predicate operations are supported:    * 'STRING' - used to filter any 'String' or 'JSON' values. Operations: EQUAL, NOT_EQUAL, STARTS_WITH, ENDS_WITH, CONTAINS, NOT_CONTAINS;   * 'NUMERIC' - used for 'Long' and 'Double' values. Operations: EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL;   * 'BOOLEAN' - used for boolean values. Operations: EQUAL, NOT_EQUAL;  * 'DATE_TIME' - similar to numeric, transforms value to milliseconds since epoch. Operations: EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL;      ## Filter Predicate  Filter Predicate defines the logical expression to evaluate. The list of available operations depends on the filter value type, see above. Platform supports 4 predicate types: 'STRING', 'NUMERIC', 'BOOLEAN' and 'COMPLEX'. The last one allows to combine multiple operations over one filter key.  Simple predicate example to check 'value < 100':   ```json {   \"operation\": \"LESS\",   \"value\": {     \"userValue\": null,     \"defaultValue\": 100,     \"dynamicValue\": null   },   \"type\": \"NUMERIC\" } ```  Complex predicate example, to check 'value < 10 or value > 20':   ```json {   \"type\": \"COMPLEX\",   \"operation\": \"OR\",   \"predicates\": [     {       \"operation\": \"LESS\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 10,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     },     {       \"operation\": \"GREATER\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 20,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     }   ] } ```  More complex predicate example, to check 'value < 10 or (value > 50 && value < 60)':   ```json {   \"type\": \"COMPLEX\",   \"operation\": \"OR\",   \"predicates\": [     {       \"operation\": \"LESS\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 10,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     },     {       \"type\": \"COMPLEX\",       \"operation\": \"AND\",       \"predicates\": [         {           \"operation\": \"GREATER\",           \"value\": {             \"userValue\": null,             \"defaultValue\": 50,             \"dynamicValue\": null           },           \"type\": \"NUMERIC\"         },         {           \"operation\": \"LESS\",           \"value\": {             \"userValue\": null,             \"defaultValue\": 60,             \"dynamicValue\": null           },           \"type\": \"NUMERIC\"         }       ]     }   ] } ```  You may also want to replace hardcoded values (for example, temperature > 20) with the more dynamic expression (for example, temperature > value of the tenant attribute with key 'temperatureThreshold'). It is possible to use 'dynamicValue' to define attribute of the tenant, customer or device. See example below:  ```json {   \"operation\": \"GREATER\",   \"value\": {     \"userValue\": null,     \"defaultValue\": 0,     \"dynamicValue\": {       \"inherit\": false,       \"sourceType\": \"CURRENT_TENANT\",       \"sourceAttribute\": \"temperatureThreshold\"     }   },   \"type\": \"NUMERIC\" } ```  Note that you may use 'CURRENT_DEVICE', 'CURRENT_CUSTOMER' and 'CURRENT_TENANT' as a 'sourceType'. The 'defaultValue' is used when the attribute with such a name is not defined for the chosen source. The 'sourceAttribute' can be inherited from the owner of the specified 'sourceType' if 'inherit' is set to true.  # Provision Configuration  There are 3 types of device provision configuration for the device profile:   * 'DISABLED';  * 'ALLOW_CREATE_NEW_DEVICES';  * 'CHECK_PRE_PROVISIONED_DEVICES'.  Please refer to the [docs](https://thingsboard.io/docs/user-guide/device-provisioning/) for more details.  # Transport Configuration  5 transport configuration types are available:  * 'DEFAULT';  * 'MQTT';  * 'LWM2M';  * 'COAP';  * 'SNMP'.  Default type supports basic MQTT, HTTP, CoAP and LwM2M transports. Please refer to the [docs](https://thingsboard.io/docs/user-guide/device-profiles/#transport-configuration) for more details about other types.  See another example of COAP transport configuration below:  ```json {    \"type\":\"COAP\",    \"clientSettings\":{       \"edrxCycle\":null,       \"powerMode\":\"DRX\",       \"psmActivityTimer\":null,       \"pagingTransmissionWindow\":null    },    \"coapDeviceTypeConfiguration\":{       \"coapDeviceType\":\"DEFAULT\",       \"transportPayloadTypeConfiguration\":{          \"transportPayloadType\":\"JSON\"       }    } } ```Remove 'id', 'tenantId' from the request body example (below) to create new Device Profile entity.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_device_profile_using_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceProfile body:
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_device_profile_using_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.save_device_profile_using_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def save_device_profile_using_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create Or Update Device Profile (saveDeviceProfile)  # noqa: E501

        Create or update the Device Profile. When creating device profile, platform generates device profile id as [time-based UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_1_(date-time_and_MAC_address)). The newly created device profile id will be present in the response. Specify existing device profile id to update the device profile. Referencing non-existing device profile Id will cause 'Not Found' error.   Device profile name is unique in the scope of tenant. Only one 'default' device profile may exist in scope of tenant.  # Device profile data definition  Device profile data object contains alarm rules configuration, device provision strategy and transport type configuration for device connectivity. Let's review some examples. First one is the default device profile data configuration and second one - the custom one.   ```json {    \"alarms\":[    ],    \"configuration\":{       \"type\":\"DEFAULT\"    },    \"provisionConfiguration\":{       \"type\":\"DISABLED\",       \"provisionDeviceSecret\":null    },    \"transportConfiguration\":{       \"type\":\"DEFAULT\"    } } ```  ```json {    \"alarms\":[       {          \"id\":\"2492b935-1226-59e9-8615-17d8978a4f93\",          \"alarmType\":\"Temperature Alarm\",          \"clearRule\":{             \"schedule\":null,             \"condition\":{                \"spec\":{                   \"type\":\"SIMPLE\"                },                \"condition\":[                   {                      \"key\":{                         \"key\":\"temperature\",                         \"type\":\"TIME_SERIES\"                      },                      \"value\":null,                      \"predicate\":{                         \"type\":\"NUMERIC\",                         \"value\":{                            \"userValue\":null,                            \"defaultValue\":30.0,                            \"dynamicValue\":null                         },                         \"operation\":\"LESS\"                      },                      \"valueType\":\"NUMERIC\"                   }                ]             },             \"dashboardId\":null,             \"alarmDetails\":null          },          \"propagate\":false,          \"createRules\":{             \"MAJOR\":{                \"schedule\":{                   \"type\":\"SPECIFIC_TIME\",                   \"endsOn\":64800000,                   \"startsOn\":43200000,                   \"timezone\":\"Europe/Kiev\",                   \"daysOfWeek\":[                      1,                      3,                      5                   ]                },                \"condition\":{                   \"spec\":{                      \"type\":\"DURATION\",                      \"unit\":\"MINUTES\",                      \"predicate\":{                         \"userValue\":null,                         \"defaultValue\":30,                         \"dynamicValue\":null                      }                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"temperature\",                            \"type\":\"TIME_SERIES\"                         },                         \"value\":null,                         \"predicate\":{                            \"type\":\"COMPLEX\",                            \"operation\":\"OR\",                            \"predicates\":[                               {                                  \"type\":\"NUMERIC\",                                  \"value\":{                                     \"userValue\":null,                                     \"defaultValue\":50.0,                                     \"dynamicValue\":null                                  },                                  \"operation\":\"LESS_OR_EQUAL\"                               },                               {                                  \"type\":\"NUMERIC\",                                  \"value\":{                                     \"userValue\":null,                                     \"defaultValue\":30.0,                                     \"dynamicValue\":null                                  },                                  \"operation\":\"GREATER\"                               }                            ]                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             },             \"WARNING\":{                \"schedule\":{                   \"type\":\"CUSTOM\",                   \"items\":[                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":1                      },                      {                         \"endsOn\":64800000,                         \"enabled\":true,                         \"startsOn\":43200000,                         \"dayOfWeek\":2                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":3                      },                      {                         \"endsOn\":57600000,                         \"enabled\":true,                         \"startsOn\":36000000,                         \"dayOfWeek\":4                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":5                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":6                      },                      {                         \"endsOn\":0,                         \"enabled\":false,                         \"startsOn\":0,                         \"dayOfWeek\":7                      }                   ],                   \"timezone\":\"Europe/Kiev\"                },                \"condition\":{                   \"spec\":{                      \"type\":\"REPEATING\",                      \"predicate\":{                         \"userValue\":null,                         \"defaultValue\":5,                         \"dynamicValue\":null                      }                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"tempConstant\",                            \"type\":\"CONSTANT\"                         },                         \"value\":30,                         \"predicate\":{                            \"type\":\"NUMERIC\",                            \"value\":{                               \"userValue\":null,                               \"defaultValue\":0.0,                               \"dynamicValue\":{                                  \"inherit\":false,                                  \"sourceType\":\"CURRENT_DEVICE\",                                  \"sourceAttribute\":\"tempThreshold\"                               }                            },                            \"operation\":\"EQUAL\"                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             },             \"CRITICAL\":{                \"schedule\":null,                \"condition\":{                   \"spec\":{                      \"type\":\"SIMPLE\"                   },                   \"condition\":[                      {                         \"key\":{                            \"key\":\"temperature\",                            \"type\":\"TIME_SERIES\"                         },                         \"value\":null,                         \"predicate\":{                            \"type\":\"NUMERIC\",                            \"value\":{                               \"userValue\":null,                               \"defaultValue\":50.0,                               \"dynamicValue\":null                            },                            \"operation\":\"GREATER\"                         },                         \"valueType\":\"NUMERIC\"                      }                   ]                },                \"dashboardId\":null,                \"alarmDetails\":null             }          },          \"propagateRelationTypes\":null       }    ],    \"configuration\":{       \"type\":\"DEFAULT\"    },    \"provisionConfiguration\":{       \"type\":\"ALLOW_CREATE_NEW_DEVICES\",       \"provisionDeviceSecret\":\"vaxb9hzqdbz3oqukvomg\"    },    \"transportConfiguration\":{       \"type\":\"MQTT\",       \"deviceTelemetryTopic\":\"v1/devices/me/telemetry\",       \"deviceAttributesTopic\":\"v1/devices/me/attributes\",       \"transportPayloadTypeConfiguration\":{          \"transportPayloadType\":\"PROTOBUF\",          \"deviceTelemetryProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage telemetry;\\n\\nmessage SensorDataReading {\\n\\n  optional double temperature = 1;\\n  optional double humidity = 2;\\n  InnerObject innerObject = 3;\\n\\n  message InnerObject {\\n    optional string key1 = 1;\\n    optional bool key2 = 2;\\n    optional double key3 = 3;\\n    optional int32 key4 = 4;\\n    optional string key5 = 5;\\n  }\\n}\",          \"deviceAttributesProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage attributes;\\n\\nmessage SensorConfiguration {\\n  optional string firmwareVersion = 1;\\n  optional string serialNumber = 2;\\n}\",          \"deviceRpcRequestProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage rpc;\\n\\nmessage RpcRequestMsg {\\n  optional string method = 1;\\n  optional int32 requestId = 2;\\n  optional string params = 3;\\n}\",          \"deviceRpcResponseProtoSchema\":\"syntax =\\\"proto3\\\";\\npackage rpc;\\n\\nmessage RpcResponseMsg {\\n  optional string payload = 1;\\n}\"       }    } } ```  Let's review some specific objects examples related to the device profile configuration:  # Alarm Schedule  Alarm Schedule JSON object represents the time interval during which the alarm rule is active. Note,   ```json \"schedule\": null ```  means alarm rule is active all the time. **'daysOfWeek'** field represents Monday as 1, Tuesday as 2 and so on. **'startsOn'** and **'endsOn'** fields represent hours in millis (e.g. 64800000 = 18:00 or 6pm). **'enabled'** flag specifies if item in a custom rule is active for specific day of the week:  ## Specific Time Schedule  ```json {    \"schedule\":{       \"type\":\"SPECIFIC_TIME\",       \"endsOn\":64800000,       \"startsOn\":43200000,       \"timezone\":\"Europe/Kiev\",       \"daysOfWeek\":[          1,          3,          5       ]    } } ```  ## Custom Schedule  ```json {    \"schedule\":{       \"type\":\"CUSTOM\",       \"items\":[          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":1          },          {             \"endsOn\":64800000,             \"enabled\":true,             \"startsOn\":43200000,             \"dayOfWeek\":2          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":3          },          {             \"endsOn\":57600000,             \"enabled\":true,             \"startsOn\":36000000,             \"dayOfWeek\":4          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":5          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":6          },          {             \"endsOn\":0,             \"enabled\":false,             \"startsOn\":0,             \"dayOfWeek\":7          }       ],       \"timezone\":\"Europe/Kiev\"    } } ```  # Alarm condition type (**'spec'**)  Alarm condition type can be either simple, duration, or repeating. For example, 5 times in a row or during 5 minutes.  Note, **'userValue'** field is not used and reserved for future usage, **'dynamicValue'** is used for condition appliance by using the value of the **'sourceAttribute'** or else **'defaultValue'** is used (if **'sourceAttribute'** is absent).  **'sourceType'** of the **'sourceAttribute'** can be:   * 'CURRENT_DEVICE';  * 'CURRENT_CUSTOMER';  * 'CURRENT_TENANT'.  **'sourceAttribute'** can be inherited from the owner if **'inherit'** is set to true (for CURRENT_DEVICE and CURRENT_CUSTOMER).  ## Repeating alarm condition  ```json {    \"spec\":{       \"type\":\"REPEATING\",       \"predicate\":{          \"userValue\":null,          \"defaultValue\":5,          \"dynamicValue\":{             \"inherit\":true,             \"sourceType\":\"CURRENT_DEVICE\",             \"sourceAttribute\":\"tempAttr\"          }       }    } } ```  ## Duration alarm condition  ```json {    \"spec\":{       \"type\":\"DURATION\",       \"unit\":\"MINUTES\",       \"predicate\":{          \"userValue\":null,          \"defaultValue\":30,          \"dynamicValue\":null       }    } } ```  **'unit'** can be:   * 'SECONDS';  * 'MINUTES';  * 'HOURS';  * 'DAYS'.  # Key Filters  Key filter objects are created under the **'condition'** array. They allow you to define complex logical expressions over entity field, attribute, latest time-series value or constant. The filter is defined using 'key', 'valueType', 'value' (refers to the value of the 'CONSTANT' alarm filter key type) and 'predicate' objects. Let's review each object:  ## Alarm Filter Key  Filter Key defines either entity field, attribute, telemetry or constant. It is a JSON object that consists the key name and type. The following filter key types are supported:  * 'ATTRIBUTE' - used for attributes values;  * 'TIME_SERIES' - used for time-series values;  * 'ENTITY_FIELD' - used for accessing entity fields like 'name', 'label', etc. The list of available fields depends on the entity type;  * 'CONSTANT' - constant value specified.  Let's review the example:  ```json {   \"type\": \"TIME_SERIES\",   \"key\": \"temperature\" } ```  ## Value Type and Operations  Provides a hint about the data type of the entity field that is defined in the filter key. The value type impacts the list of possible operations that you may use in the corresponding predicate. For example, you may use 'STARTS_WITH' or 'END_WITH', but you can't use 'GREATER_OR_EQUAL' for string values.The following filter value types and corresponding predicate operations are supported:    * 'STRING' - used to filter any 'String' or 'JSON' values. Operations: EQUAL, NOT_EQUAL, STARTS_WITH, ENDS_WITH, CONTAINS, NOT_CONTAINS;   * 'NUMERIC' - used for 'Long' and 'Double' values. Operations: EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL;   * 'BOOLEAN' - used for boolean values. Operations: EQUAL, NOT_EQUAL;  * 'DATE_TIME' - similar to numeric, transforms value to milliseconds since epoch. Operations: EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL;      ## Filter Predicate  Filter Predicate defines the logical expression to evaluate. The list of available operations depends on the filter value type, see above. Platform supports 4 predicate types: 'STRING', 'NUMERIC', 'BOOLEAN' and 'COMPLEX'. The last one allows to combine multiple operations over one filter key.  Simple predicate example to check 'value < 100':   ```json {   \"operation\": \"LESS\",   \"value\": {     \"userValue\": null,     \"defaultValue\": 100,     \"dynamicValue\": null   },   \"type\": \"NUMERIC\" } ```  Complex predicate example, to check 'value < 10 or value > 20':   ```json {   \"type\": \"COMPLEX\",   \"operation\": \"OR\",   \"predicates\": [     {       \"operation\": \"LESS\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 10,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     },     {       \"operation\": \"GREATER\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 20,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     }   ] } ```  More complex predicate example, to check 'value < 10 or (value > 50 && value < 60)':   ```json {   \"type\": \"COMPLEX\",   \"operation\": \"OR\",   \"predicates\": [     {       \"operation\": \"LESS\",       \"value\": {         \"userValue\": null,         \"defaultValue\": 10,         \"dynamicValue\": null       },       \"type\": \"NUMERIC\"     },     {       \"type\": \"COMPLEX\",       \"operation\": \"AND\",       \"predicates\": [         {           \"operation\": \"GREATER\",           \"value\": {             \"userValue\": null,             \"defaultValue\": 50,             \"dynamicValue\": null           },           \"type\": \"NUMERIC\"         },         {           \"operation\": \"LESS\",           \"value\": {             \"userValue\": null,             \"defaultValue\": 60,             \"dynamicValue\": null           },           \"type\": \"NUMERIC\"         }       ]     }   ] } ```  You may also want to replace hardcoded values (for example, temperature > 20) with the more dynamic expression (for example, temperature > value of the tenant attribute with key 'temperatureThreshold'). It is possible to use 'dynamicValue' to define attribute of the tenant, customer or device. See example below:  ```json {   \"operation\": \"GREATER\",   \"value\": {     \"userValue\": null,     \"defaultValue\": 0,     \"dynamicValue\": {       \"inherit\": false,       \"sourceType\": \"CURRENT_TENANT\",       \"sourceAttribute\": \"temperatureThreshold\"     }   },   \"type\": \"NUMERIC\" } ```  Note that you may use 'CURRENT_DEVICE', 'CURRENT_CUSTOMER' and 'CURRENT_TENANT' as a 'sourceType'. The 'defaultValue' is used when the attribute with such a name is not defined for the chosen source. The 'sourceAttribute' can be inherited from the owner of the specified 'sourceType' if 'inherit' is set to true.  # Provision Configuration  There are 3 types of device provision configuration for the device profile:   * 'DISABLED';  * 'ALLOW_CREATE_NEW_DEVICES';  * 'CHECK_PRE_PROVISIONED_DEVICES'.  Please refer to the [docs](https://thingsboard.io/docs/user-guide/device-provisioning/) for more details.  # Transport Configuration  5 transport configuration types are available:  * 'DEFAULT';  * 'MQTT';  * 'LWM2M';  * 'COAP';  * 'SNMP'.  Default type supports basic MQTT, HTTP, CoAP and LwM2M transports. Please refer to the [docs](https://thingsboard.io/docs/user-guide/device-profiles/#transport-configuration) for more details about other types.  See another example of COAP transport configuration below:  ```json {    \"type\":\"COAP\",    \"clientSettings\":{       \"edrxCycle\":null,       \"powerMode\":\"DRX\",       \"psmActivityTimer\":null,       \"pagingTransmissionWindow\":null    },    \"coapDeviceTypeConfiguration\":{       \"coapDeviceType\":\"DEFAULT\",       \"transportPayloadTypeConfiguration\":{          \"transportPayloadType\":\"JSON\"       }    } } ```Remove 'id', 'tenantId' from the request body example (below) to create new Device Profile entity.   Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_device_profile_using_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceProfile body:
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_device_profile_using_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_default_device_profile_using_post(self, device_profile_id, **kwargs):  # noqa: E501
        """Make Device Profile Default (setDefaultDeviceProfile)  # noqa: E501

        Marks device profile as default within a tenant scope.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_device_profile_using_post(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_default_device_profile_using_post_with_http_info(device_profile_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_default_device_profile_using_post_with_http_info(device_profile_id, **kwargs)  # noqa: E501
            return data

    def set_default_device_profile_using_post_with_http_info(self, device_profile_id, **kwargs):  # noqa: E501
        """Make Device Profile Default (setDefaultDeviceProfile)  # noqa: E501

        Marks device profile as default within a tenant scope.  Available for users with 'TENANT_ADMIN' authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_default_device_profile_using_post_with_http_info(device_profile_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_profile_id: A string value representing the device profile id. For example, '784f394c-42b6-435a-983c-b7beff2784f9' (required)
        :return: DeviceProfile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_profile_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_default_device_profile_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_profile_id' is set
        if ('device_profile_id' not in params or
                params['device_profile_id'] is None):
            raise ValueError("Missing the required parameter `device_profile_id` when calling `set_default_device_profile_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_profile_id' in params:
            path_params['deviceProfileId'] = params['device_profile_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['X-Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/api/deviceProfile/{deviceProfileId}/default', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceProfile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
